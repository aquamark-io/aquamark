<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Diagonal Watermark Tool</title>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>
  <h1>PDF Diagonal Watermark Tool</h1>
  <div>
    <input type="file" id="pdfInput" accept="application/pdf" />
    <button onclick="embedWatermark()">Watermark & Download</button>
    <div id="status" style="margin-top: 10px;"></div>
  </div>

  <script>
    const logoUrl = "https://www.aquamark.io/logo-full-black-blue.png";
    const statusElement = document.getElementById("status");

    async function embedWatermark() {
      try {
        statusElement.textContent = "Processing...";
        const input = document.getElementById("pdfInput");
        if (!input.files.length) {
          alert("Please upload a PDF file.");
          statusElement.textContent = "";
          return;
        }

        // Load the original PDF
        const pdfBytes = await input.files[0].arrayBuffer();
        const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
        
        // Create a watermark PDF
        const watermarkDoc = await PDFLib.PDFDocument.create();
        const logoImageBytes = await fetch(logoUrl).then(res => res.arrayBuffer());
        const logoImage = await watermarkDoc.embedPng(logoImageBytes);
        
        // Add watermark page with same dimensions as first page of original
        const { width, height } = pdfDoc.getPages()[0].getSize();
        const watermarkPage = watermarkDoc.addPage([width, height]);
        
        // Calculate dimensions for smaller repeating logos
        const logoWidth = width * 0.2;  // Smaller logo size
        const logoHeight = (logoWidth / logoImage.width) * logoImage.height;
        
        // Create diagonal pattern of logos
        const rows = 5;
        const cols = 5;
        const spacingX = width / cols;
        const spacingY = height / rows;
        
        // Draw the checkered diagonal pattern - original top-left to bottom-right
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            // Only draw on alternating positions for checkered effect
            if ((i + j) % 2 === 0) {
              // Position calculation for diagonal-like layout
              const x = j * spacingX + (i * width / (rows * 2));
              const y = i * spacingY;
              
              // Draw the logo with rotation
              watermarkPage.drawImage(logoImage, {
                x: x % width,  // Wrap around if beyond page width
                y,
                width: logoWidth,
                height: logoHeight,
                opacity: 0.15,
                rotate: PDFLib.degrees(45)  // Rotate each logo 45 degrees
              });
            }
          }
        }
        
        // Add top-right to bottom-left diagonal
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if ((i + j) % 2 === 0) {
              // Position calculation for the reverse diagonal layout
              const x = width - (j * spacingX + (i * width / (rows * 2))) - logoWidth;
              const y = i * spacingY;
              
              watermarkPage.drawImage(logoImage, {
                x: (x + width) % width,  // Ensure it wraps properly
                y,
                width: logoWidth,
                height: logoHeight,
                opacity: 0.15,
                rotate: PDFLib.degrees(-45)  // Rotate in opposite direction
              });
            }
          }
        }
        
        // Add bottom-left to top-right diagonal
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if ((i + j) % 2 === 0) {
              const x = j * spacingX + (i * width / (rows * 2));
              const y = height - (i * spacingY) - logoHeight;
              
              watermarkPage.drawImage(logoImage, {
                x: x % width,
                y,
                width: logoWidth,
                height: logoHeight,
                opacity: 0.15,
                rotate: PDFLib.degrees(-45)
              });
            }
          }
        }
        
        // Add bottom-right to top-left diagonal
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if ((i + j) % 2 === 0) {
              const x = width - (j * spacingX + (i * width / (rows * 2))) - logoWidth;
              const y = height - (i * spacingY) - logoHeight;
              
              watermarkPage.drawImage(logoImage, {
                x: (x + width) % width,
                y,
                width: logoWidth,
                height: logoHeight,
                opacity: 0.15,
                rotate: PDFLib.degrees(45)
              });
            }
          }
        }
        
        // Embed the watermark page
        const watermarkPdfBytes = await watermarkDoc.save();
        const watermarkEmbed = await PDFLib.PDFDocument.load(watermarkPdfBytes);
        const [embeddedPage] = await pdfDoc.embedPages([watermarkEmbed.getPages()[0]]);
        
        // Apply watermark to each page
        for (const page of pdfDoc.getPages()) {
          const { width, height } = page.getSize();
          page.drawPage(embeddedPage, { x: 0, y: 0, width, height });
        }
        
        // Save and download
        const modifiedPdfBytes = await pdfDoc.save();
        const blob = new Blob([modifiedPdfBytes], { type: "application/pdf" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "watermarked-" + input.files[0].name;
        link.click();
        
        statusElement.textContent = "Complete";
      } catch (error) {
        statusElement.textContent = "Error: " + error.message;
      }
    }
  </script>
</body>
</html>
