<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Diagonal Watermark Tool</title>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>
  <h1>PDF Diagonal Watermark Tool</h1>
  <div>
    <input type="file" id="pdfInput" accept="application/pdf" />
    <button onclick="embedWatermark()">Watermark & Download</button>
    <div id="status" style="margin-top: 10px;"></div>
  </div>

  <script>
    const logoUrl = "https://www.aquamark.io/logo-full-black-blue.png";
    const statusElement = document.getElementById("status");

    async function embedWatermark() {
  try {
    statusElement.textContent = "Processing...";
    const input = document.getElementById("pdfInput");
    if (!input.files.length) {
      alert("Please upload a PDF file.");
      statusElement.textContent = "";
      return;
    }

    const pdfBytes = await input.files[0].arrayBuffer();
    const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);

    const barcodeUrl = "barcode.png"; // Make sure this is accessible
    const logoUrl = "https://www.aquamark.io/logo-full-black-blue.png";

    // Load logo
    const logoImageBytes = await fetch(logoUrl).then(res => res.arrayBuffer());
    const logoImage = await pdfDoc.embedPng(logoImageBytes);

    // Load barcode (force PNG)
    const barcodeBytes = await fetch(barcodeUrl).then(res => res.arrayBuffer());
    const barcodeImage = await pdfDoc.embedPng(barcodeBytes);

    const pages = pdfDoc.getPages();
    const { width, height } = pages[0].getSize();

    // Watermark logic
    const rows = 6;
    const cols = 6;
    const logoWidth = width * 0.2;
    const logoHeight = (logoWidth / logoImage.width) * logoImage.height;
    const spacingX = width / cols;
    const spacingY = height / rows;

    // Create watermark layout on a separate page
    const wmDoc = await PDFLib.PDFDocument.create();
    const wmPage = wmDoc.addPage([width, height]);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        if ((i + j) % 2 === 0) {
          const x = j * spacingX + (i * spacingX / 2);
          const y = i * spacingY;
          wmPage.drawImage(logoImage, {
            x,
            y,
            width: logoWidth,
            height: logoHeight,
            opacity: 0.15,
            rotate: PDFLib.degrees(45),
          });
        }
      }
    }

    const wmBytes = await wmDoc.save();
    const wmEmbed = await PDFLib.PDFDocument.load(wmBytes);
    const [wmPageEmbed] = await pdfDoc.embedPages([wmEmbed.getPages()[0]]);

    for (let i = 0; i < pages.length; i++) {
      const page = pages[i];
      page.drawPage(wmPageEmbed, { x: 0, y: 0, width, height });

      // Add vertical margin message + barcode on page 1 only
if (i === 0) {
  const prefix = "Important: Watermarked by document owner. Any use or submission by other parties is unauthorized and likely theft. Contact ";
  const email = "support@aquamark.io";
  const suffix = " immediately.";

  const x = width - 16;
  const y = 30; // moved down half an inch from previous (was 60)

  // Draw prefix
  page.drawText(prefix, {
    x,
    y,
    size: 8,
    color: PDFLib.rgb(0.2, 0.2, 0.2),
    rotate: PDFLib.degrees(90),
    opacity: 0.6,
    lineHeight: 10,
  });

  // Draw email in blue + underline
  page.drawText(email, {
    x,
    y + 150, // email appears after ~15 characters rotated vertically
    size: 8,
    color: PDFLib.rgb(0.0, 0.4, 0.8), // blue
    rotate: PDFLib.degrees(90),
    opacity: 0.8,
    underline: true,
  });

  // Draw suffix
  page.drawText(suffix, {
    x,
    y + 310, // offset to follow email
    size: 8,
    color: PDFLib.rgb(0.2, 0.2, 0.2),
    rotate: PDFLib.degrees(90),
    opacity: 0.6,
  });
}
    }

    const finalBytes = await pdfDoc.save();
    const blob = new Blob([finalBytes], { type: "application/pdf" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "watermarked-" + input.files[0].name;
    link.click();
    statusElement.textContent = "Complete";
  } catch (error) {
    statusElement.textContent = "❌ Error: " + error.message;
    console.error(error);
  }
}

  </script>
</body>
</html>
